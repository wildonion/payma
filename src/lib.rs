
/*


    `ed25519` keypair for server checksum and licensing, updating and verification using 
    its commit (like ssh keys), also time hash based (**`hash(user_id + time + ip + user agent)`**) 
    locking api with rate limit feature to avoid guarded api call spamming (like sleeping in thread 
    or using snowflake id based on client secret keys) using `argon2`, `rust-crypto`, `noise` and `ring` tools


    - Openssl and ed25519 and tokio rustls also secret chat based on a derived secret key for bot users per device 
    - cryptography algos(hex editor, bytes, seeds, xor, nor, &, |, include!, ed25519(pub/prv keys and base58))
    - ed25519: public key is the wallet address in which we can verify the signature of the signed tx | seed will be used to generate keypair and private key is the pen to sign tx and generate signature | both public and private key are of type &[u8; 32] which are a 32 bytes slice of utf8

    >>>>>>>> u8 bytes -> &str using str::from_utf8()
    >>>>>>>> &str -> u8 bytes using as_bytes() or as_bytes_mut()
    >>>>>>>> u8 -> u16 using transmute or shift bits operations (shift 2 bytes) or u8 to hex ascii string then to u16 using self::from_hex_string_to_u16() function
    >>>>>>>> u8 -> hex ascii string using self::from_u8_to_hex_string() function
    >>>>>>>> hex ascii string to u8 or u16 using from_str_radix()
    >>>>>>>> u8 -> hex ascii vector using :x? in println! macro or dividing operations : u8 bytes % 16 



    Malware in rust using ram concepts (static and const are in segment data and let is on the stack)
    injectable code like .so and .dll

    hardware coding, 
    memory layout and offset, 
    playing with byte, hex and pointers
    unsafe coding
    writing engines
    convert this contract into a wasm module to be loadable inside js
    steganography using binding techniques like .so and bpf elf

    zero copy      ::::: https://github.com/wildonion/uniXerr/blob/a30a9f02b02ec7980e03eb8e31049890930d9238/infra/valhalla/coiniXerr/src/schemas.rs#L1621C6-L1621C6
    data collision ::::: https://github.com/wildonion/uniXerr/blob/a30a9f02b02ec7980e03eb8e31049890930d9238/infra/valhalla/coiniXerr/src/utils.rs#L640
    
    https://crates.io/crates/wasmtime
    https://wasmer.io/
    https://github.com/skerkour/black-hat-rust/tree/main/ch_11
    https://cryptobook.nakov.com/digital-signatures
    https://github.com/wildonion/cs-concepts

    ------
    TASK-1
    ------
    encrypt the whole os using ring based on PGP keypairs
    we can decrypt it with private key only and the victim
    must pay for the private key
    ...

    ------
    TASK 2
    ------
    sha256 of the file must be equals to the one generated by the server to verify the file signature
    software and code update and data encryption using PGP cert keys and ed25519 public key digital signature
    symmetric single private key for en(de)cryption
    asymmetric ed25519 digital signature key 
    --- has of public key which is wallet
    --- private key can be used to sign tx
    --- seed phrase can be used to generate the keypairs 
    --- public key can be used to verify the signature agains the utf8 bytes of data
    ...

    ------
    TASK 3
    ------
    smart contract to pay developer salary based on github commits using escrow contract
    1 - generate keypair for both parties
    2 - employee deposit the full payment into this contract 
    3 - the whole moeny will be mapped to the contractor in this contract
    4 - on every 10 commits, confirmed by the employee full/10 will be transferred to the contractor
    5 - we run step 4 inside a loop{} until all the moeny gets paid to the contractor
    

*/







mod constants;
use constants::KEYPAIR;
use ring::{signature::KeyPair, pkcs8::Document};
use ring::signature::Ed25519KeyPair;
use std::fmt::Write;
use ring::{signature as ring_signature, rand as ring_rand};



/* 
    we cannot obtain &'static str from a String because Strings may not live 
    for the entire life of our program, and that's what &'static lifetime means. 
    we can only get a slice parameterized by String own lifetime from it, we can 
    obtain a static str but it involves leaking the memory of the String. this is 
    not something we should do lightly, by leaking the memory of the String, this 
    guarantees that the memory will never be freed (thus the leak), therefore, any 
    references to the inner object can be interpreted as having the 'static lifetime.
    
    also here it's ok to return the reference from function since our reference lifetime 
    is static and is valid for the entire life of the app
*/
// TODO - Box and Pin methods
pub fn string_to_static_str(s: String) -> &'static str { 
    /* 
        leaking the memory of the heap data String which allows us to have an 
        unfreed allocation that can be used to define static str using it since
        static means we have static lifetime during the whole lifetime of the app
        and reaching this using String is not possible because heap data types 
        will be dropped from the heap once their lifetime destroyed in a scope
        like by moving them into another scope hence they can't be live longer 
        than static lifetime
    */
    Box::leak(s.into_boxed_str()) 
}


pub fn from_u8_to_hex_string(bytes: &[u8]) -> Result<String, ()> { //// take a reference from u8 and will return a hex String
    
    use hex::*;
    
    let msg = "get";
    let msg_bytes = msg.as_bytes();
    /* 
                    hex representation of u16 and u8 bits

        `get` payload in hex will be 0x676574 since `g` is 67 in hex
        which is 103 in decimal which is in form of utf8 bytes means that 
        every char in form of utf8 bytes must be in range 0 up to 255
        also every char in hex is 4 bits in binary which means every two
        chars in hex is 1 byte in utf8 bytes thus 0x676574 is 3 bytes in 
        form of utf8 bytes also chars can be represented in form of utf16 
        or 2 bytes long, like `get` is 0xfeff0067feff0065feff0074 in hex which
        is 12 bytes long or 24 hex chars because `get` has 3 chars which in 
        utf16 form every char has size of 2 bytes which is 4 chars in hex 
        thus 3 * 4 = 12 bytes in total for 3 chars in utf16 form.

        representation of char in utf8 will be fallen in range 0 up to 255
        since 2**8 is 256 and in u16 will be fallen in range 0 up to 65536
        since 2**16 is 65536, accordingly each char has longer length of hex
        in u16 like a char in hex has 4 chars in hex and in u8 has 2 chars
        in hex.

    */
    let playload_hex_ascii = msg_bytes.iter().map(|b| format!("{:x}", b)).collect::<String>();
    println!("{playload_hex_ascii:}");


    ///// -------------- union, enum and struct -------------- /////
    /*
        offset is the size in bytes and in order to get
        the starting offset of a type or struct instance 
        we can get a raw pointer (since smart pointer in rust 
        will be coerced to raw pointers at compile time) 
        to the instance then cast that pointer to usize 
        which is the size in bytes of the instance pointer itself
    */
    
    /*
        a pointer contains the memory address of an obejct
        and it has either 32 or 64 bits (depends on the os arc)
        size hence we can get it's size by casting it into the 
        usize type that contains the size of that pointer in bytes
        inside the stack
    */
 
    struct Object{
        a: u8, //// we can fill this in a hex form
        b: u16, //// we can fill this in a hex form
        c: u32, //// we can fill this in a hex form
    }

    // utf8 hex representation
    let obj = Object{
        /*
            since `a` field is of type u8 thus we have to fill 
            it with only two chars in hex since every 4 bits 
            in base 2 is a hex char; the 0xaa is 170 in decimal
            0xaa is one byte or 8 bits
        */
        a: 0xaa, 
        /*
            since `b` field is of type u16 thus we have to fill 
            it with only four chars in hex since every 4 bits 
            in base 2 is a hex char; the 0xaa is 48059 in decimal
            0xbbbb is two bytes or 16 bits
        */
        b: 0xbbbb, 
        /*
            since `c` field is of type u32 thus we have to fill 
            it with only eight chars in hex since every 4 bits 
            in base 2 is a hex char; the 0xcccccccc is 3435973836 in decimal
            0xcccccccc is two bytes or 32 bits
        */
        c: 0xcccccccc
    };

    /*
        usize is an unsigned size which is big enough
        to store any pointer and in 32 bits arch is 4 bytes
        and in 64 bits is 8 bytes also each usize contains 
        the size in bytes in either 32 or 64 bits format
    //
        base is the usize pointer of the object itself 
        which contains the size of the starting offset 
        in bytes in memory, we've just cast the pointer 
        to the location of the obj instance into the usize
        to get the size of its pointer in bytes which is the 
        starting offset of all its fields
    */
    let base = &obj as *const _ as usize; //// we're considering the pointer of the obj instance as the starting point of the offset by converting its pointer into usize 
    let a_off = &obj.a as *const _ as usize - base; //// this is the `a` field offset by subtracting its usize pointer (cast its *const pointer to usize) from the base offset
    let b_off = &obj.b as *const _ as usize - base; //// this is the `b` field offset by subtracting its usize pointer (cast its *const pointer to usize) from the base offset
    let c_off = &obj.c as *const _ as usize - base; //// this is the `c` field offset by subtracting its usize pointer (cast its *const pointer to usize) from the base offset
    println!("base: {}", base); 
    println!("a: {}", a_off as usize - base);
    println!("b: {}", b_off as usize - base);
    println!("c: {}", c_off as usize - base);


    /*
        let hex_ascii_string = "hello world".as_bytes().iter().map(|x| format!("{:02x}", x)).collect::<String>()
        >> let mut s = String::new();
        >> use std::fmt::Write as FmtWrite; // renaming import to avoid collision
        >> for b in "hello world".as_bytes() { write!(s, "{:02x}", b); }
        ()
        >> s
        "68656c6c6f20776f726c64"
        >> 
    */
    let hex_arr = &[0x23u8, 0xF2u8];
    let mut buffer = String::with_capacity(bytes.len() * 2); //// length of the String must be double of the size of the u8 cause we want to write u16 or hex into this buffer
    for &b in bytes {
        write!(&mut buffer, "{:02x}", b).expect("⚠️ writing to String buffer error for hex ascii"); //// writing formatted data into the buffer which is the String - panic on any error
    }
    Ok(buffer)
}

pub fn from_hex_string_to_u8(hex_string: &str) -> Result<Vec<u8>, ()>{
    let mut hex_bytes = hex_string.as_bytes().iter().filter_map(|b| {
        match b {
            b'0'..=b'9' => Some(b - b'0'),
            b'a'..=b'f' => Some(b - b'a' + 10),
            b'A'..=b'F' => Some(b - b'A' + 10),
            _ => None,
        }
    }).fuse();

    let mut bytes = Vec::new();
    while let (Some(h), Some(l)) = (hex_bytes.next(), hex_bytes.next()) {
        bytes.push(h << 4 | l)
    }
    Ok(bytes)
}

pub fn from_hex_string_to_u16(s: &str) -> Result<Vec<u16>, std::num::ParseIntError> {
    (0..s.len())
        .step_by(2)
        .map(|i| u16::from_str_radix(&s[i..i + 2], 16))
        .collect()
}



/* ED25519 implementation using ring */
pub struct Contract{
    keypair: &'static Ed25519KeyPair,
    prvkey: Vec<u8>,
    pub iat: i64,
    pub owner: &'static str
}

impl Contract{
    pub fn new(owner: &str) -> Self{
        
        let static_owner = string_to_static_str(owner.to_string());
        let keypair = KEYPAIR.0.as_ref();
        let Ok(keys) = keypair else{
            panic!("can't generate keypair due to: {:?}", keypair.unwrap_err());
        };

        /* ED25519 keypair */
        let pubkey = keys.public_key().as_ref();
        let prvkey = KEYPAIR.1.as_ref();

        Self { keypair: keys, prvkey: prvkey.to_vec(), iat: chrono::Local::now().timestamp_nanos(), owner: static_owner }
        
    }

    pub fn get_public_key(&self) -> Vec<u8>{


        self.keypair.public_key().as_ref().to_vec()

    }

    pub fn get_private_key(&self) -> Vec<u8>{

        /* 
            cloning the self to prevent from moving since returning 
            heap data from method will move the self 
        */
        self.prvkey.clone()

    }

    pub fn sign(&self, data: &str) -> Vec<u8>{


        let signature = self.keypair.sign(data.as_bytes());
        signature.as_ref().to_vec()


    }

    pub fn is_valid_transaction(&self, sig: Vec<u8>, data: &str) -> bool{
        self.verify_signature(sig, data)
    }

    fn verify_signature(&self, sig: Vec<u8>, data: &str) -> bool{

        let message = data.as_bytes();
        let pubkey = self.keypair.public_key().as_ref();
        let ring_pubkey = ring_signature::UnparsedPublicKey::new(&ring_signature::ED25519, pubkey);

        /* 
            Vec<u8> can be coerced to &[u8] slice by taking a reference to it 
            since a pointer to the underlying Vec<u8> means taking a slice of 
            vector with a valid lifetime
        */
        match ring_pubkey.verify(message, &sig){ 
            Ok(_) => true,
            Err(_) => false
        }

    }

    pub fn generate_keys_from(&self, prv_key: &[u8]) -> Ed25519KeyPair{

        /* constructing keypair from the private key */
        let private_key = hex::decode(&prv_key).unwrap();
        let generated_ed25519_keys = Ed25519KeyPair::from_pkcs8(private_key.as_ref()).unwrap();
        generated_ed25519_keys

    }


}
